void (entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer;
void (entity spy) TeamFortress_SpyCalcName;
void () CF_Spy_UndercoverThink;
void () GasGrenadeMakeGas;
void () T_TranqDartTouch;
void () Spy_DropBackpack;

void () spy_diea1 =[50, spy_diea2] {
};

void () spy_diea2 =[51, spy_diea3] {
};

void () spy_diea3 =[52, spy_diea4] {
};

void () spy_diea4 =[53, spy_diea5] {
};

void () spy_diea5 =[54, spy_diea6] {
};

void () spy_diea6 =[55, spy_diea7] {
};

void () spy_diea7 =[56, spy_diea8] {
};

void () spy_diea8 =[57, spy_diea9] {
};

void () spy_diea9 =[58, spy_diea10] {
};

void () spy_diea10 =[59, spy_diea11] {
};

void () spy_diea11 =[60, spy_diea11] {
};

void () spy_dieb1 =[61, spy_dieb2] {
};

void () spy_dieb2 =[62, spy_dieb3] {
};

void () spy_dieb3 =[63, spy_dieb4] {
};

void () spy_dieb4 =[64, spy_dieb5] {
};

void () spy_dieb5 =[65, spy_dieb6] {
};

void () spy_dieb6 =[66, spy_dieb7] {
};

void () spy_dieb7 =[67, spy_dieb8] {
};

void () spy_dieb8 =[68, spy_dieb9] {
};

void () spy_dieb9 =[69, spy_dieb9] {
};

void () spy_diec1 =[70, spy_diec2] {
};

void () spy_diec2 =[71, spy_diec3] {
};

void () spy_diec3 =[72, spy_diec4] {
};

void () spy_diec4 =[73, spy_diec5] {
};

void () spy_diec5 =[74, spy_diec6] {
};

void () spy_diec6 =[75, spy_diec7] {
};

void () spy_diec7 =[76, spy_diec8] {
};

void () spy_diec8 =[77, spy_diec9] {
};

void () spy_diec9 =[78, spy_diec10] {
};

void () spy_diec10 =[79, spy_diec11] {
};

void () spy_diec11 =[80, spy_diec12] {
};

void () spy_diec12 =[81, spy_diec13] {
};

void () spy_diec13 =[82, spy_diec14] {
};

void () spy_diec14 =[83, spy_diec15] {
};

void () spy_diec15 =[84, spy_diec15] {
};

void () spy_died1 =[85, spy_died2] {
};

void () spy_died2 =[86, spy_died3] {
};

void () spy_died3 =[87, spy_died4] {
};

void () spy_died4 =[88, spy_died5] {
};

void () spy_died5 =[89, spy_died6] {
};

void () spy_died6 =[90, spy_died7] {
};

void () spy_died7 =[91, spy_died8] {
};

void () spy_died8 =[92, spy_died9] {
};

void () spy_died9 =[93, spy_died9] {
};

void () spy_diee1 =[94, spy_diee2] {
};

void () spy_diee2 =[95, spy_diee3] {
};

void () spy_diee3 =[96, spy_diee4] {
};

void () spy_diee4 =[97, spy_diee5] {
};

void () spy_diee5 =[98, spy_diee6] {
};

void () spy_diee6 =[99, spy_diee7] {
};

void () spy_diee7 =[100, spy_diee8] {
};

void () spy_diee8 =[101, spy_diee9] {
};

void () spy_diee9 =[102, spy_diee9] {
};

void () spy_die_ax1 =[41, spy_die_ax2] {
};

void () spy_die_ax2 =[42, spy_die_ax3] {
};

void () spy_die_ax3 =[43, spy_die_ax4] {
};

void () spy_die_ax4 =[44, spy_die_ax5] {
};

void () spy_die_ax5 =[45, spy_die_ax6] {
};

void () spy_die_ax6 =[46, spy_die_ax7] {
};

void () spy_die_ax7 =[47, spy_die_ax8] {
};

void () spy_die_ax8 =[48, spy_die_ax9] {
};

void () spy_die_ax9 =[49, spy_die_ax9] {
};

void () spy_upb1 =[69, spy_upb2] {
};

void () spy_upb2 =[68, spy_upb3] {
};

void () spy_upb3 =[67, spy_upb4] {
};

void () spy_upb4 =[66, spy_upb5] {
};

void () spy_upb5 =[65, spy_upb6] {
};

void () spy_upb6 =[64, spy_upb7] {
};

void () spy_upb7 =[63, spy_upb8] {
};

void () spy_upb8 =[62, spy_upb9] {
};

void () spy_upb9 =[61, spy_upb9] {
    player_stand1();
};

void () spy_upc1 =[84, spy_upc2] {
};

void () spy_upc2 =[83, spy_upc3] {
};

void () spy_upc3 =[82, spy_upc4] {
};

void () spy_upc4 =[81, spy_upc5] {
};

void () spy_upc5 =[80, spy_upc6] {
};

void () spy_upc6 =[79, spy_upc7] {
};

void () spy_upc7 =[78, spy_upc8] {
};

void () spy_upc8 =[77, spy_upc9] {
};

void () spy_upc9 =[76, spy_upc10] {
};

void () spy_upc10 =[75, spy_upc11] {
};

void () spy_upc11 =[74, spy_upc12] {
};

void () spy_upc12 =[73, spy_upc13] {
};

void () spy_upc13 =[72, spy_upc14] {
};

void () spy_upc14 =[71, spy_upc15] {
};

void () spy_upc15 =[70, spy_upc15] {
    player_stand1();
};

void () spy_upd1 =[93, spy_upd2] {
};

void () spy_upd2 =[92, spy_upd3] {
};

void () spy_upd3 =[91, spy_upd4] {
};

void () spy_upd4 =[90, spy_upd5] {
};

void () spy_upd5 =[89, spy_upd6] {
};

void () spy_upd6 =[88, spy_upd7] {
};

void () spy_upd7 =[87, spy_upd8] {
};

void () spy_upd8 =[86, spy_upd9] {
};

void () spy_upd9 =[85, spy_upd9] {
    player_stand1();
};

void () spy_upe1 =[94, spy_upe9] {
};

void () spy_upe9;
void () spy_upe2 =[95, spy_upe8] {
};

void () spy_upe8;
void () spy_upe3 =[96, spy_upe7] {
};

void () spy_upe7;
void () spy_upe4 =[97, spy_upe6] {
};

void () spy_upe6;
void () spy_upe5 =[98, spy_upe5] {
};

void () spy_upe6 =[99, spy_upe4] {
};

void () spy_upe7 =[100, spy_upe3] {
};

void () spy_upe8 =[101, spy_upe2] {
};

void () spy_upe9 =[102, spy_upe1] {
    player_stand1();
};

void () spy_upaxe1 =[49, spy_upaxe2] {
};

void () spy_upaxe2 =[48, spy_upaxe3] {
};

void () spy_upaxe3 =[47, spy_upaxe4] {
};

void () spy_upaxe4 =[46, spy_upaxe5] {
};

void () spy_upaxe5 =[45, spy_upaxe6] {
};

void () spy_upaxe6 =[44, spy_upaxe7] {
};

void () spy_upaxe7 =[43, spy_upaxe8] {
};

void () spy_upaxe8 =[42, spy_upaxe9] {
};

void () spy_upaxe9 =[41, spy_upaxe9] {
    player_stand1();
};

float (entity pe_player) Spy_CheckArea = {
    local entity at_spot = findradius(pe_player.origin, 64);
    while (at_spot != world) {
        if (at_spot.mdl == "progs/detpack.mdl"
                    || at_spot.mdl == "progs/turrbase.mdl"
                    || at_spot.mdl == "progs/turrgun.mdl"
                    || at_spot.mdl == "progs/disp.mdl")
            return 1;
        else if (at_spot.classname == "player" && pe_player != at_spot) {
            if (!at_spot.is_feigning && at_spot.deadflag == 0)
                return 2;
            else if (at_spot.is_feigning)
                return 3;
        }
        at_spot = at_spot.chain;
    }
    return 0;
};

void () CF_Spy_AirThink = {
    local float area_check = 0;

    if ((self.owner.deadflag >= 2) || (self.owner.playerclass != PC_SPY) || (!self.owner.is_feigning)) {
        dremove(self);
        return;
    }

    // only do stuff when spy is no longer moving
    if (!self.owner.velocity) {

        // if spy is on ground and an entity is not nearby, set movetype to none (so he can't move)
        if (self.owner.flags & FL_ONGROUND) {
            area_check = Spy_CheckArea(self.owner);
            if (area_check == 0) {
                self.owner.movetype = MOVETYPE_NONE;
                self.owner.tfstate = self.owner.tfstate | TFSTATE_CANT_MOVE;
            }
        }

        // if spy is in the air, set movetype to walk (so he falls to ground)
        else {
            self.owner.movetype = MOVETYPE_WALK;
        }

        TeamFortress_SetSpeed(self.owner);

    }

    self.nextthink = time + 0.1;
};

void (float issilent) CF_Spy_FeignDeath = {
    local string deathstring;
    local float area_check;
    local float i;
    local entity te, spy;

    if (self.is_feigning) {

        // check area for obstructing entities
        area_check = Spy_CheckArea(self);

        // nothing on top => unfeign
        if (!area_check) {

            // set size of player model
            setsize(self, VEC_HULL_MIN, VEC_HULL_MAX);

            // set view height
            self.view_ofs = '0 0 22';

            // unset feign variables
            self.is_feigning = 0;
            self.feign_areachecked = 0;

            // load saved weapon state and set current ammo
            W_WeaponState_Load(self, 0);
            W_SetCurrentAmmo(self);

            // allow spy to move again
            self.movetype = MOVETYPE_WALK;
            self.tfstate = self.tfstate - (self.tfstate & TFSTATE_CANT_MOVE);
            TeamFortress_SetSpeed(self);

            // set revive animation
            i = 1 + floor(random() * 5);
            if (i == 1) {
                spy_upb1();
            } else if (i == 2) {
                spy_upc1();
            } else if (i == 3) {
                spy_upd1();
            } else {
                spy_upe1();
            }

        // something is on top of spy
        } else if (area_check == 1) {
            sprint(self, PRINT_HIGH, "You cannot get up with something on top of you\n");
        } else if (area_check == 2) {
            sprint(self, PRINT_HIGH, "You cannot get up while someone is standing on you\n");
        }
    } else {

        // don't feign spam timer is active
        if (time < self.antispam_feign) {
            sprint(self, PRINT_HIGH, "You cannot feign right now\n");
            return;
        }

        // don't allow feign if spy is in air and air feigning is disallowed
        if (!feign_air && !(self.flags & FL_ONGROUND)) {
            sprint(self, PRINT_HIGH, "You cannot feign while you are airborne\n");
            return;
        }

        // check area for feigned spy on the ground
        area_check = Spy_CheckArea(self);
        if (area_check == 3) {
            sprint(self, PRINT_HIGH, "You cannot feign on top of another spy\n");
            return;
        }

        // stop spy from attempting feign for 3 seconds
        self.antispam_feign = time + 3;

        // don't check for team color cheat for 5 seconds
        self.immune_to_check = time + 5;

        // set movetype to toss
        self.movetype = MOVETYPE_TOSS;

        // this timer will make sure the spy falls
        // to the ground when possible
        spy = spawn();
        spy.classname = "airtimer";
        spy.owner = self;
        spy.think = CF_Spy_AirThink;
        spy.nextthink = time + 0.1;

        // set spy feign variables
        self.is_feigning = 1;

        Attack_Finished(0.8);
        self.invisible_finished = 0;

        // set precached model index
        self.modelindex = modelindex_player;

        // set size of player model
        setsize(self, '-16 -16 -24', '16 16 -16');

        // set weapon state and remove weapon viewmodel
        W_WeaponState_Save(self);
        self.weaponmodel = "";
        self.weaponframe = 0;

        // set view height to ground
        self.view_ofs = '0 0 4';

        // do extra stuff if feign is not silent feign
        if (issilent == 0) {
            // make a death sound
            DeathSound();

            // drop an empty backpack (if this is not disabled in settings)
            if (feign_pack)
                Spy_DropBackpack();

            // print feign message (if this is not disabled in settings)
            if (feign_msg) {
                deathstring = GetDeathMessage(self, self.attacked_by, self.feignmsg);
                bprint(PRINT_MEDIUM, deathstring);
            }

            // set movement speed to 0 if currently in the air to disable manipulation of trajectory
            if (!(self.flags & FL_ONGROUND))
                self.maxspeed = 0;
        }

        // drop flag if spy is carrying it
        te = find(world, classname, "item_tfgoal");
        while (te) {
            if (te.owner == self) {
                if (!(te.goal_activation & TFGI_KEEP) || self.has_disconnected == 1)
                    tfgoalitem_RemoveFromPlayer(te, self, 0);
                if (CTF_Map == 1) {
                    if (te.goal_no == 1)
                        bprint(PRINT_HIGH, self.netname, " лост the блуе flag!\n");
                    else if (te.goal_no == 2)
                        bprint(PRINT_HIGH, self.netname, " лост the ред flag!\n");
                }
            }
            te = find(te, classname, "item_tfgoal");
        }

        // die with axe equipped if carrying axe, medikit or spanner
        if (self.weapon <= WEAP_AXE) {
            spy_die_ax1();
            return;
        }

        // randomize death animation
        i = 1 + floor((random() * 6));
        if (i == 1)
            spy_diea1();
        else if (i == 2)
            spy_dieb1();
        else if (i == 3)
            spy_diec1();
        else if (i == 4)
            spy_died1();
        else
            spy_diee1();
    }
};

void () CF_Spy_Invisible = {
    local entity e_timer;

    if (self.effects & (EF_DIMLIGHT | EF_BRIGHTLIGHT)) {
        sprint(self, PRINT_MEDIUM, "You cannot become invisible while glowing\n");
        return;
    }

    if (self.is_unabletospy) {
        sprint(self, PRINT_HIGH, "You cannot become invisible right now\n");
        return;
    }

    if (self.is_undercover == 1 || self.items & IT_INVISIBILITY) {

        self.items = self.items - IT_INVISIBILITY;
        self.invisible_finished = 0;
        self.invisible_time = 0;
        self.is_undercover = 0;
        self.modelindex = modelindex_player;

    } else if (self.is_undercover == 2) {

        sprint(self, PRINT_HIGH, "You become visible again\n");

        self.is_undercover = 0;

    } else if (self.ammo_cells > 1) {

        sprint(self, PRINT_HIGH, "Going invisible...\n");

        self.is_undercover = 2;

        // create a timer for 4 seconds
        e_timer = spawn();
        e_timer.classname = "spytimer";
        e_timer.owner = self;
        e_timer.think = CF_Spy_UndercoverThink;
        e_timer.nextthink = time + 1;
        self.undercover_timer = 4;
    }

    Status_Refresh(self);

};

void () CF_Spy_DisguiseStop = {
    local entity e_timer;
    local string s_class, s_team;

    if (!self.is_undercover)
        return;

    // set undercover class if spy had the time to change class
    if (self.undercover_skin)
        s_class = TeamFortress_GetClassName(self.undercover_skin);
    else
        s_class = "Spy";

    // set undercover team if spy had the time to change team
    if (self.undercover_team)
        s_team = TeamFortress_TeamGetColorString(self.undercover_team);
    else
        s_team = TeamFortress_TeamGetColorString(self.team_no);

    // show what's left of the disguise
    if (self.undercover_skin || self.undercover_team) {
        sprint(self, PRINT_HIGH, "Disguised as ", s_team, " ", s_class, "\n");
        self.is_undercover = 1;
        self.last_skin = self.undercover_skin;
        self.last_team = self.undercover_team;
    } else {
        sprint(self, PRINT_HIGH, "You stop going undercover\n");
        self.is_undercover = 0;
    }

    self.disguise_skin = 0;
    self.disguise_team = 0;
    self.queue_skin = 0;
    self.queue_team = 0;

    // remove disguise timers belonging to self
    e_timer = find(world, classname, "spytimer");
    while (e_timer != world) {
        if (e_timer.owner == self) {
            dremove(e_timer);
            e_timer = find(world, classname, "spytimer");
        } else {
            e_timer = find(e_timer, classname, "spytimer");
        }
    }

    Status_Refresh(self);

};

void () CF_Spy_DisguiseLast = {
    if (self.last_skin) {
        CF_Spy_ChangeSkin(self, self.last_skin);
    }
    if (self.last_team) {
        CF_Spy_ChangeColor(self, self.last_team);
    }
};

void () CF_Spy_UndercoverThink = {
    local float f_team_color;
    local string s_team, s_class;

    // keep track of seconds left to
    if (self.owner.undercover_timer > 1) {
        self.owner.undercover_timer = self.owner.undercover_timer - 1;
        self.nextthink = time + 1;
        Status_Refresh(self.owner);
        return;
    }

    // stop if player is not a spy
    if (self.owner.playerclass != PC_SPY)
        return;

    // stop if spy is not going undercover
    if (self.owner.is_undercover != 2)
        return;

    // make spy invisible if invis_only is turned on
    if (invis_only) {

        self.owner.items = self.owner.items | IT_INVISIBILITY;
        self.owner.frame = 0;
        self.owner.modelindex = modelindex_eyes;
        self.owner.is_undercover = 1;

    } else {

        // don't check for color cheating for next 10 seconds
        self.owner.immune_to_check = time + 10;

        if (self.skin) {
            self.owner.undercover_skin = self.skin;
            self.owner.last_skin = self.skin;
            self.owner.disguise_skin = 0;
            self.owner.queue_skin = 0;
            self.owner.is_undercover = 1;
            TeamFortress_SetSkin(self.owner);

            if (self.owner.queue_team) {
                CF_Spy_ChangeColor(self.owner, self.owner.queue_team);
            } else {
                if (self.owner.undercover_team)
                    s_team = TeamFortress_TeamGetColorString(self.owner.undercover_team);
                else
                    s_team = TeamFortress_TeamGetColorString(self.owner.team_no);
                if (self.owner.undercover_skin)
                    s_class = TeamFortress_GetClassName(self.owner.undercover_skin);
                else
                    s_class = "Spy";
                sprint(self.owner, PRINT_HIGH, "Disguised as ", s_team, " ", s_class, "\n");
            }

        } else if (self.team) {
            self.owner.undercover_team = self.team;
            self.owner.last_team = self.team;

            // tell client to change color
            f_team_color = TeamFortress_TeamGetColor(self.team) - 1;
            stuffcmd(self.owner, "color ");
            stuffcmd(self.owner, ftos(f_team_color));
            stuffcmd(self.owner, "\n");
            self.owner.queue_team = 0;
            self.owner.is_undercover = 1;
            TeamFortress_SetSkin(self.owner);

            if (self.owner.queue_skin) {
                CF_Spy_ChangeSkin(self.owner, self.owner.queue_skin);
            } else {
                s_team = TeamFortress_TeamGetColorString(self.owner.undercover_team);
                if (self.owner.undercover_skin)
                    s_class = TeamFortress_GetClassName(self.owner.undercover_skin);
                else
                    s_class = "Spy";
                sprint(self.owner, PRINT_HIGH, "Disguised as ", s_team, " ", s_class, "\n");
            }
        }

        TeamFortress_SpyCalcName(self.owner);

    }

    Status_Refresh(self.owner);
    if (self.owner.menu_input == Menu_Spy_Input)
        Menu_Spy(self.owner);
    dremove(self);

};

void (entity pe_player, float pf_class) CF_Spy_ChangeSkin = {
    local entity e_timer;

    // stop if you're already disguised as the requested skin
    if (pe_player.undercover_skin == pf_class)
        return;

    // stop if you're glowing
    if (pe_player.effects & (EF_DIMLIGHT | EF_BRIGHTLIGHT))
        return;

    // stop if you're unable to spy
    if (pe_player.is_unabletospy)
        return;

    // reset skin if skin is set to spy
    if (pf_class == PC_SPY) {
        sprint(pe_player, PRINT_HIGH, "Skin reset\n");
        pe_player.undercover_skin = 0;
        pe_player.disguise_skin = 0;
        pe_player.queue_skin = 0;
        TeamFortress_SetSkin(pe_player);
        if (!pe_player.undercover_team)
            pe_player.is_undercover = 0;
        return;
    }

    // queue skin change if currently going undercover
    if (pe_player.is_undercover == 2) {
        pe_player.queue_skin = pf_class;
        return;
    }

    // prepare disguise
    if (!pe_player.undercover_team)
        sprint(pe_player, PRINT_HIGH, "Going undercover...\n");
    pe_player.is_undercover = 2;
    pe_player.disguise_skin = pf_class;
    pe_player.disguise_team = 0;

    // disguise timer, finishes in 4 seconds
    e_timer = spawn();
    e_timer.classname = "spytimer";
    e_timer.owner = pe_player;
    e_timer.think = CF_Spy_UndercoverThink;
    e_timer.nextthink = time + 1;
    e_timer.skin = pf_class;
    pe_player.undercover_timer = 4;
    TeamFortress_SetSkin(pe_player);

    Status_Refresh(pe_player);
};

void (entity pe_player, float pf_team_no) CF_Spy_ChangeColor = {
    local entity e_timer;
    local float f_team_color = TeamFortress_TeamGetColor(pf_team_no) - 1;

    // stop if you're already disguised as the requested skin
    if (pe_player.undercover_team == pf_team_no)
        return;

    // stop if you're glowing
    if (pe_player.effects & (EF_DIMLIGHT | EF_BRIGHTLIGHT))
        return;

    // stop if you're unable to spy
    if (pe_player.is_unabletospy)
        return;

    // reset team if team is set to home team
    if (pf_team_no == pe_player.team_no) {
        sprint(pe_player, PRINT_HIGH, "Colors reset\n");
        pe_player.immune_to_check = time + 10;
        pe_player.undercover_team = 0;
        pe_player.disguise_team = 0;
        pe_player.queue_team = 0;
        stuffcmd(pe_player, "color ");
        stuffcmd(pe_player, ftos(f_team_color));
        stuffcmd(pe_player, "\n");
        if (!pe_player.undercover_skin)
            pe_player.is_undercover = 0;
        TeamFortress_SetSkin(pe_player);
        return;
    }

    // queue team change if currently going undercover
    if (pe_player.is_undercover == 2) {
        pe_player.queue_team = pf_team_no;
        return;
    }

    // prepare disguise
    if (!pe_player.undercover_skin)
        sprint(pe_player, PRINT_HIGH, "Going undercover...\n");
    pe_player.is_undercover = 2;
    pe_player.disguise_skin = 0;
    pe_player.disguise_team = pf_team_no;

    // disguise timer, finishes in 4 seconds
    e_timer = spawn();
    e_timer.classname = "spytimer";
    e_timer.owner = pe_player;
    e_timer.think = CF_Spy_UndercoverThink;
    e_timer.nextthink = time + 4;
    e_timer.team = pf_team_no;

    Status_Refresh(pe_player);
};

void (entity spy) TeamFortress_SpyCalcName = {
    local entity te;

    spy.undercover_name = string_null;
    if (spy.undercover_team != 0) {
        te = find(world, classname, "player");
        while (te) {
            if ((te.team_no == spy.undercover_team) &&
                (te.skin == spy.undercover_skin)) {
                spy.undercover_name = te.netname;
                te = world;
            } else {
                te = find(te, classname, "player");
            }
        }
        if (spy.undercover_name == string_null) {
            te = find(world, classname, "player");
            while (te) {
                if (te.team_no == spy.undercover_team) {
                    spy.undercover_name = te.netname;
                    te = world;
                } else {
                    te = find(te, classname, "player");
                }
            }
        }
    }
};

void () GasGrenadeTouch = {
    sound(self, 1, "weapons/bounce.wav", 1, 1);
    if (self.velocity == '0 0 0')
        self.avelocity = '0 0 0';
};

void () GasGrenadeExplode = {
    local entity te;
    local float pos;

    pos = pointcontents(self.origin);
    if (pos == -1) {
        te = spawn();
        te.think = GasGrenadeMakeGas;
        te.nextthink = time + 0.1;
        te.classname = "gastimer";
        te.heat = 0;
        te.origin = self.origin;
        te.owner = self.owner;
        te.team_no = self.owner.team_no;
        te.weapon = 0;
        te.enemy = self;
    } else {
        pos = 0;
        while (pos < 10) {
            newmis = spawn();
            setmodel(newmis, "progs/s_bubble.spr");
            setorigin(newmis, self.origin);
            newmis.movetype = 8;
            newmis.solid = 0;
            newmis.velocity = '0 0 15';
            newmis.velocity_z = 10 + (random() * 20);
            newmis.nextthink = time + 0.5;
            newmis.think = bubble_bob;
            newmis.classname = "bubble";
            newmis.frame = 0;
            newmis.cnt = 0;
            setsize(newmis, '-8 -8 -8', '8 8 8');
            pos = pos + 1;
        }
    }
    dremove(self);
};

void () GasGrenadeMakeGas = {
    local entity te;
    local entity timer;

    if (self.heat == 0) {
        self.owner.no_active_gas_grens =
            self.owner.no_active_gas_grens + 1;
        if (self.owner.no_active_gas_grens > 2) {
            te = find(world, classname, "gastimer");
            while (te) {
                if ((te.owner == self.owner) &&
                    (te.no_active_gas_grens == 1)) {
                    te.weapon = 24;
                    te.think = RemoveGrenade;
                    te.nextthink = time + 0.1;
                }
                te = find(te, classname, "gastimer");
            }
        }
        self.no_active_gas_grens = self.owner.no_active_gas_grens;
    }
    self.nextthink = time + 0.75;
    te = findradius(self.origin, 200);
    while (te != world) {
        if (((te.classname == "player") && (te.deadflag == 0)) &&
            (te.has_disconnected != 1)) {
            deathmsg = 24;
            TF_T_Damage(te, world, self.owner, 10, (1 | 2), 0);
            if (te.tfstate & 16384) {
                timer = find(world, classname, "timer");
                while (((timer.owner != te) ||
                        (timer.think != HallucinationTimer)) &&
                       (timer != world)) {
                    timer = find(timer, classname, "timer");
                }
                if (timer != world) {
                    timer.health = timer.health + 25;
                    if (old_grens == 1) {
                        if (timer.health < 100) {
                            timer.health = 100;
                        }
                        timer.nextthink = time + 0.5;
                    } else {
                        if (timer.health < 150) {
                            timer.health = 150;
                        }
                        timer.nextthink = time + 0.3;
                    }
                }
            } else {
                if (old_grens == 1) {
                    stuffcmd(te, "v_cshift 50 25 50 -50\n");
                    sprint(te, PRINT_HIGH, "Far out man!\n");
                } else {
                    sprint(te, PRINT_HIGH,
                           "Run for cover! They are everywhere!\n");
                }
                te.tfstate = te.tfstate | TFSTATE_HALLUCINATING;
                timer = spawn();
                if (old_grens == 1)
                    timer.nextthink = time + 0.5;
                else
                    timer.nextthink = time + 0.3;
                timer.think = HallucinationTimer;
                timer.classname = "timer";
                timer.owner = te;
                if (old_grens == 1)
                    timer.health = 100;
                else
                    timer.health = 150;
                timer.team_no = self.team_no;
            }
        }
        te = te.chain;
    }
    self.heat = self.heat + 1;
    if (self.heat == 1) {
        WriteByte(MSG_MULTICAST, SVC_TEMPENTITY);
        WriteByte(MSG_MULTICAST, TE_TAREXPLOSION);
        WriteCoord(MSG_MULTICAST, self.origin_x);
        WriteCoord(MSG_MULTICAST, self.origin_y);
        WriteCoord(MSG_MULTICAST, self.origin_z);
        multicast(self.origin, MULTICAST_PVS);
        return;
    }
    if (self.heat <= 20) {
        self.weapon = self.weapon + 1;
        if (self.weapon == 1) {
            WriteByte(MSG_MULTICAST, SVC_TEMPENTITY);
            WriteByte(MSG_MULTICAST, TE_LAVASPLASH);
            WriteCoord(MSG_MULTICAST, self.origin_x);
            WriteCoord(MSG_MULTICAST, self.origin_y);
            WriteCoord(MSG_MULTICAST, self.origin_z - 24);
            multicast(self.origin, MULTICAST_PVS);
        } else if (self.weapon == 2)
            self.weapon = 0;
        return;
    }
    RemoveGrenade();
};

void () HallucinationTimer = {
    local entity te;
    local float tmpx;
    local float tmpy;
    local float halltype;
    local float halltype2;
    local string st;

    self.health = self.health - 2.5;
    if (self.owner.playerclass == PC_MEDIC) {
        self.health = self.health - 2.5;
    }
    if (((self.health <= 0) || (self.owner.deadflag != 0)) ||
        (self.owner.has_disconnected == 1)) {
        self.owner.tfstate =
            self.owner.tfstate - (self.owner.tfstate & 16384);
    }
    if ((self.owner.deadflag != 0) || (self.owner.has_disconnected == 1)) {
        dremove(self);
        return;
    }
    if (!(self.owner.tfstate & 16384)) {
        if (old_grens == 1)
            stuffcmd(self.owner, "v_cshift; wait; bf\n");
        sprint(self.owner, 2, "You feel a little better now\n");
        dremove(self);
        return;
    }
    if (old_grens == 1)
        self.nextthink = time + 0.5;
    else
        self.nextthink = time + 0.3;

    if (random() < 0.5)
        KickPlayer(-10, self.owner);

    if (old_grens == 1) {
        stuffcmd(self.owner, "v_cshift ");
        halltype = random() * 100;
        st = ftos(halltype);
        stuffcmd(self.owner, st);
        stuffcmd(self.owner, " ");
        halltype = random() * 100;
        st = ftos(halltype);
        stuffcmd(self.owner, st);
        stuffcmd(self.owner, " ");
        halltype = random() * 100;
        st = ftos(halltype);
        stuffcmd(self.owner, st);
        stuffcmd(self.owner, " -75\n");
    }
    tmpx = random() * 800 - 400;
    tmpy = random() * 800 - 400;
    halltype = random();
    halltype2 = random();
    msg_entity = self.owner;
    if (halltype < 0.4) {
        WriteByte(MSG_ONE, SVC_TEMPENTITY);
        if (halltype < 0.25) {
            WriteByte(MSG_ONE, TE_EXPLOSION);
        } else if (halltype < 0.35) {
            WriteByte(MSG_ONE, TE_TAREXPLOSION);
        } else {
            WriteByte(MSG_ONE, TE_LAVASPLASH);
        }
        WriteCoord(MSG_ONE, msg_entity.origin_x + tmpx);
        WriteCoord(MSG_ONE, msg_entity.origin_y + tmpy);
        WriteCoord(MSG_ONE, msg_entity.origin_z);

        if (old_grens != 1)
            T_Damage(self.owner, self.owner, self.owner, 0);

    } else if (halltype < 0.7) {
        WriteByte(MSG_ONE, SVC_TEMPENTITY);
        WriteByte(MSG_ONE, TE_TELEPORT);
        WriteCoord(MSG_ONE, msg_entity.origin_x + tmpx);
        WriteCoord(MSG_ONE, msg_entity.origin_y + tmpy);
        WriteCoord(MSG_ONE, msg_entity.origin_z);

        if (old_grens != 1) {
            if (halltype2 < 0.1) {
                stuffcmd(self.owner, "play weapons/r_exp3.wav\n");
            } else if (halltype2 < 0.15) {
                stuffcmd(self.owner, "play weapons/rocket1i.wav\n");
            } else if (halltype2 < 0.2) {
                stuffcmd(self.owner, "play weapons/sgun1.wav\n");
            } else if (halltype2 < 0.25) {
                stuffcmd(self.owner, "play weapons/guncock.wav\n");
            } else if (halltype2 < 0.3) {
                stuffcmd(self.owner, "play weapons/ric1.wav\n");
            } else if (halltype2 < 0.35) {
                stuffcmd(self.owner, "play weapons/ric2.wav\n");
            } else if (halltype2 < 0.4) {
                stuffcmd(self.owner, "play weapons/ric3.wav\n");
            } else if (halltype2 < 0.45) {
                stuffcmd(self.owner, "play weapons/spike2.wav\n");
            } else if (halltype2 < 0.5) {
                stuffcmd(self.owner, "play weapons/tink1.wav\n");
            } else if (halltype2 < 0.55) {
                CenterPrint2(self.owner, "\n\n\n",
                             "Your team цаптуред the flag!!");
                stuffcmd(self.owner, "play weapons/grenade.wav\n");
            } else if (halltype2 < 0.6) {
                stuffcmd(self.owner, "play weapons/bounce.wav\n");
            } else if (halltype2 < 0.65) {
                stuffcmd(self.owner, "play weapons/shotgn2.wav\n");
            } else if (halltype2 < 0.7) {
                stuffcmd(self.owner, "play wizard/wattack.wav\n");
            } else if (halltype2 < 0.75) {
                stuffcmd(self.owner, "play items/r_item1.wav\n");
            } else if (halltype2 < 0.8) {
                stuffcmd(self.owner, "play items/r_item2.wav\n");
            } else if (halltype2 < 0.85) {
                CenterPrint(self.owner, "You are on fire!\n");
                stuffcmd(self.owner, "play weapons/lhit.wav\n");
            } else if (halltype2 < 0.9) {
                stuffcmd(self.owner, "play misc/r_tele1.wav\n");
            } else {
                stuffcmd(self.owner, "play weapons/railgun.wav\n");
            }
        }
    } else {
        te = spawn();
        te.origin_x = msg_entity.origin_x + tmpx;
        te.origin_y = msg_entity.origin_y + tmpy;
        te.origin_z = msg_entity.origin_z;

        WriteByte(MSG_ONE, SVC_TEMPENTITY);
        WriteByte(MSG_ONE, TE_LIGHTNING2);
        WriteEntity(MSG_ONE, te);
        WriteCoord(MSG_ONE, te.origin_x);
        WriteCoord(MSG_ONE, te.origin_y);
        WriteCoord(MSG_ONE, te.origin_z);
        tmpx = random() * 800 - 400;
        tmpy = random() * 800 - 400;
        WriteCoord(MSG_ONE, msg_entity.origin_x + tmpx);
        WriteCoord(MSG_ONE, msg_entity.origin_y + tmpy);
        WriteCoord(MSG_ONE, msg_entity.origin_z);

        if (old_grens != 1) {
            if (halltype2 < 0.1) {
                stuffcmd(self.owner, "play weapons/detpack.wav\n");
            } else if (halltype2 < 0.2) {
                stuffcmd(self.owner, "play weapons/turrset.wav\n");
            } else if (halltype2 < 0.3) {
                stuffcmd(self.owner, "play weapons/turrspot.wav\n");
            } else if (halltype2 < 0.4) {
                stuffcmd(self.owner, "play weapons/turridle.wav\n");
            } else if (halltype2 < 0.5) {
                stuffcmd(self.owner, "play weapons/sniper.wav\n");
            } else if (halltype2 < 0.6) {
                CenterPrint2(self.owner, "\n\n\n",
                             "Your flag has been такен!!");
                stuffcmd(self.owner, "play weapons/flmfire2.wav\n");
            } else if (halltype2 < 0.7) {
                stuffcmd(self.owner, "play weapons/flmgrexp.wav\n");
            } else if (halltype2 < 0.8) {
                stuffcmd(self.owner, "play misc/vapeur2.wav\n");
            } else if (halltype2 < 0.9) {
                stuffcmd(self.owner, "play weapons/asscan1.wav\n");
            } else {
                stuffcmd(self.owner, "play weapons/asscan2.wav\n");
            }
        }
        dremove(te);
    }
};

void () W_FireTranq = {
    self.ammo_shells = self.ammo_shells - 1;
    self.currentammo = self.ammo_shells;
    KickPlayer(-2, self);
    newmis = spawn();
    newmis.owner = self;
    newmis.movetype = 9;
    newmis.solid = 2;
    makevectors(self.v_angle);
    newmis.velocity = v_forward;
    newmis.velocity = newmis.velocity * 1500;
    newmis.angles = vectoangles(newmis.velocity);
    newmis.touch = T_TranqDartTouch;
    newmis.think = SUB_Remove;
    newmis.nextthink = time + 6;
    setmodel(newmis, "progs/spike.mdl");
    setsize(newmis, '0 0 0', '0 0 0');
    setorigin(newmis, self.origin + v_forward * 8 + '0 0 16');
};

void () T_TranqDartTouch = {
    local entity timer;

    if (other.solid == 1)
        return;

    if (pointcontents(self.origin) == CONTENT_SKY) {
        dremove(self);
        return;
    }
    if (other.takedamage) {
        if ((other.classname == "player") &&
            !((other.team_no == self.owner.team_no) &&
              (teamplay & (2 | 4)))) {
            if (other.tfstate & 32768) {
                timer = find(world, classname, "timer");
                while (((timer.owner != other) ||
                        (timer.think != TranquiliserTimer)) &&
                       (timer != world)) {
                    timer = find(timer, classname, "timer");
                }
                if (timer != world) {
                    timer.nextthink = time + 15;
                }
            } else {
                sprint(other, 2, "You feel tired...\n");
                other.tfstate = other.tfstate | 32768;
                timer = spawn();
                timer.nextthink = time + 15;
                timer.think = TranquiliserTimer;
                timer.classname = "timer";
                timer.owner = other;
                timer.team_no = self.owner.team_no;
                TeamFortress_SetSpeed(other);
            }
        }
        spawn_touchblood(9);
        deathmsg = 25;
        TF_T_Damage(other, self, self.owner, 20, 2, 2);
    } else {
        WriteByte(4, 23);
        if (self.classname == "wizspike") {
            WriteByte(4, 7);
        } else {
            if (self.classname == "knightspike") {
                WriteByte(4, 8);
            } else {
                WriteByte(4, 0);
            }
        }
        WriteCoord(4, self.origin_x);
        WriteCoord(4, self.origin_y);
        WriteCoord(4, self.origin_z);
        multicast(self.origin, 2);
    }
    dremove(self);
};

void () TranquiliserTimer = {
    self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 32768);
    TeamFortress_SetSpeed(self.owner);
    sprint(self.owner, PRINT_HIGH, "You feel more alert now\n");
    dremove(self);
};

void (entity spy) Spy_RemoveDisguise = {
    local string st;
    local float tc;
    local float coverblown = 0;

    if (invis_only != 1) {
        if (spy.playerclass == 8) {
            if (spy.undercover_team != 0) {
                spy.immune_to_check = time + 10;
                spy.undercover_team = 0;
                spy.disguise_team = 0;
                stuffcmd(spy, "color ");
                tc = TeamFortress_TeamGetColor(spy.team_no) - 1;
                st = ftos(tc);
                stuffcmd(spy, st);
                stuffcmd(spy, "\n");
                coverblown = 1;
            }
            if (spy.undercover_skin != 0) {
                spy.immune_to_check = time + 10;
                spy.undercover_skin = 0;
                spy.disguise_skin = 0;
                spy.skin = 0;
                coverblown = 1;
            }
            spy.is_undercover = 0;
            Status_Refresh(self);
            TeamFortress_SetSkin(spy);
            TeamFortress_SpyCalcName(spy);
        }
    } else if (spy.is_undercover) {
        coverblown = 1;
        spy.is_undercover = 0;
        spy.modelindex = modelindex_player;
        if (spy.items & 524288) {
            spy.invisible_finished = 0;
            spy.invisible_time = 0;
            spy.items = spy.items - 524288;
        }
        Status_Refresh(self);
    }
    if (coverblown)
        Status_Print(self, "\n\n\n\n\n\n\n", "You blew your cover!");
};

void () Spy_DropBackpack = {
    if ((cb_prematch_time + 3) > time)
        return;

    newmis = spawn();
    newmis.origin = self.origin - '0 0 24';

    newmis.ammo_shells = 0;
    newmis.ammo_nails = 0;
    newmis.ammo_rockets = 0;
    newmis.ammo_cells = 0;

    newmis.armorvalue = 0;

    newmis.velocity_z = 300;
    newmis.velocity_x = -100 + random() * 200;
    newmis.velocity_y = -100 + random() * 200;

    newmis.flags = FL_ITEM;
    newmis.solid = SOLID_TRIGGER;
    newmis.movetype = MOVETYPE_TOSS;
    setmodel(newmis, "progs/backpack.mdl");
    setsize(newmis, '-16 -16 0', '16 16 56');
    newmis.touch = BackpackTouch;

    newmis.nextthink = time + 120;
    newmis.think = SUB_Remove;
};
